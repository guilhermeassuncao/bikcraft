/* Cascata

    Folhas de estilo em cascata - em um nível muito simples, isso significa que a ordem das regras CSS é importante; quando duas regras se aplicam com especificidade igual, a que vier por último no CSS é a que será usada. No exemplo abaixo, temos duas regras que podem ser aplicadas ao h1. O h1 acaba sendo colorido de azul - essas regras têm um seletor idêntico e, portanto, carregam a mesma especificidade, portanto, o último na ordem de origem vence.

        Exemplo:

            h1 { 
                color: red; 
            }
            
            h1 { 
                color: blue; 
            }

    Há três fatores a serem considerados, listados aqui em ordem crescente de importância. Os posteriores anulam os anteriores:

        - Ordem de fonte: Já vimos como a ordem da fonte é importante para a cascata. Se você tiver mais de uma regra, que tenha exatamente o mesmo peso, a que vier por último no CSS será a vencedora. Você pode pensar nisso como regras que estão mais próximas do próprio elemento, sobrescrevendo as primeiras até que a última vença e dê estilo ao elemento;

        - Especificidade: Depois de compreender o fato de que a ordem da fonte é importante, em algum momento você se deparará com uma situação em que saberá que uma regra vem depois na folha de estilo, mas uma regra anterior conflitante é aplicada. Isso ocorre porque a regra anterior tem uma especificidade mais alta - é mais específica e, portanto, está sendo escolhida pelo navegador como a que deve estilizar o elemento;

        - Importância: Existe uma parte especial do CSS que você pode usar para ignorar todos os cálculos acima, no entanto, você deve ter muito cuidado ao usá-lo - !important. Isso é usado para tornar uma determinada propriedade e valor a coisa mais específica, substituindo assim as regras normais da cascata.

*/
     
/* Especificidade

    A especificação é a maneira de como os navegadores definem quais valores de propriedades são os mais relevantes para o elemento a ser utilizado. A especificação é baseada apenas nas regras impostas na composição de diferentes tipos de seletores. A seguinte lista de seletores está incluida na especificação:

        - Seletores Universais;                                              
        
            * {
                margin-top: 5rem;
            }

            (0, 0, 0, 0)

        - Tipo de Seletores e Pseudo-elementos;                             

            h1 {
                color: red;
            }

            (0, 0, 0, 1)

            h1::before {
                  content: "«";
                    color: blue;
            }

            (0, 0, 0, 2)

        - Classes seletoras;                                                

            .classe {
                color: pink;
            }

            (0, 0, 1, 0)
            
        - Atributos Seletores;                                              

            [type="radio"] {
                font-size: 1rem;
            }

            (0, 0, 1, 0)

        - Pseudo-classes;                                                   

            button:hover {
                padding: 2rem;
            }

            (0, 0, 1, 0)
            
        - Seletores ID;                                                     

            #id {
                margin-top: 5rem;
            }

            (0, 1, 0, 0)

        - Estilo Inline;                                                    

            <h1 style="color:blue;">Titulo</h1>

            (1, 0, 0, 0)


    Vamos agora dar uma olhada em como o navegador calculará a especificidade. Já sabemos que um seletor de elemento tem baixa especificidade e pode ser substituído por uma classe.  Essencialmente, um valor em pontos é concedido a diferentes tipos de seletores, e a soma deles dá a você o peso daquele seletor específico, que pode então ser avaliado em relação a outras combinações potenciais.

    A quantidade de especificidade de um seletor é medida usando quatro valores (ou componentes) diferentes, que podem ser considerados como milhares, centenas, dezenas e uns - quatro dígitos únicos em quatro colunas:

        - Milhares: Marque um nesta coluna se a declaração estiver dentro de um style atributo, também conhecido como estilos embutidos. Essas declarações não têm seletores, então sua especificidade é sempre 1000;

        - Centenas: Marque um nesta coluna para cada seletor de ID contido no seletor geral;

        - Dezenas: Marque um nesta coluna para cada seletor de classe, seletor de atributo ou pseudoclasse contido no seletor geral;

        - Um: Marque um nesta coluna para cada seletor de elemento ou pseudoelemento contido dentro do seletor geral.

    A exceção !important, quando a regra !important é utilizada na declaração do estilo substitui qualquer outra declaração feita no CSS, onde quer que esteja na lista de declaração. Contudo, !important não tem nada a ver com especificação. A exceção :not, A pseudo-classe de negação :not não é considerada uma pseudo-classe no cálculo de especificação. Contudo, seletores colocados na pseudo-class de negação são entendidos como seletores normais.

        Exemplo de Calculo de Especificidade

            CSS 1

                ul > li {
                    color: blue;
                }

                (0, 0, 0, 2)

            CSS 2

                .list > .list-item {
                    color: red;
                    }

                    (0, 0, 2, 0)
            
            HTML

                <ul class="list">
                    <li class="list-item"></li>
                    <li class="list-item"></li>
                    <li class="list-item"></li>
                    <li class="list-item"></li>
                </ul>

            Resultado

                CSS 2 tem uma especificidade mais alta do que CSS 1, porque usa dois nomes de classe em comparação com dois nomes de seletor. Assim, os elementos do item da lista terão uma cor vermelha.

*/

/* Herança

    Em CSS, a herança controla o que acontece quando nenhum valor é especificado para uma propriedade em um elemento.

    As propriedades CSS podem ser categorizadas em dois tipos:

        - propriedades herdadas , que por padrão são definidas para o valor calculado do elemento pai;

        - propriedades não herdadas , que por padrão são definidas para o valor inicial da propriedade.

    Propriedades herdadas

        Quando nenhum valor para uma propriedade herdada foi especificado em um elemento, o elemento obtém o valor calculado dessa propriedade em seu elemento pai. Apenas o elemento raiz do documento obtém o valor inicial fornecido no resumo da propriedade. Um exemplo típico de propriedade herdada é a colorpropriedade. Dadas as regras de estilo: 
        
            Exemplo:
            
                p { color: green; }

    Propriedades não herdadas

        Quando nenhum valor para uma propriedade não herdada foi especificado em um elemento, o elemento obtém o valor inicial dessa propriedade (conforme especificado no resumo da propriedade). Um exemplo típico de propriedade não herdada é a borderpropriedade. Dadas as regras de estilo:

            Exemplo:

                p { border: medium solid; }

    CSS fornece quatro valores especiais de propriedade universal para controlar a herança. Cada propriedade CSS aceita esses valores.

        - inherit: Define o valor da propriedade aplicado a um elemento selecionado para ser o mesmo de seu elemento pai. Efetivamente, isso "ativa a herança";

        - initial: Define o valor da propriedade aplicado a um elemento selecionado para o valor inicial dessa propriedade;

        - unset: Restaura a propriedade com seu valor natural, o que significa que se a propriedade for herdada naturalmente, ela age como inherit, caso contrário, ela age como initial;

        - revert: Especifica o comportamento que depende da origem da folha de estilo à qual a declaração pertence:

                - Origem do agente do usuário: Equivalente a não definido;
                
                - Origem do usuário: Reverte a cascata para o nível do agente do usuário, para que os valores especificados sejam calculados como se nenhuma regra no nível do autor ou do usuário tivesse sido especificada para o elemento;

                - Origem do autor: Reverte a cascata para o nível do usuário, de forma que os valores especificados sejam calculados como se nenhuma regra de nível de autor tivesse sido especificada para o elemento. Para fins de reversão, a origem do Autor inclui as origens de Substituição e Animação.

*/

/* !important

    Quando uma importantregra é usada em uma declaração de estilo, esta declaração substitui qualquer outra declaração. Embora tecnicamente !importantnão tenha nada a ver com especificidade, ele interage diretamente com ela. Usar !important,, entretanto, é uma prática ruim e deve ser evitado porque torna a depuração mais difícil ao interromper a cascata natural em suas folhas de estilo. Quando duas declarações conflitantes com a !importantregra forem aplicadas ao mesmo elemento, será aplicada a declaração com maior especificidade.

    Algumas regras básicas:

        - Sempre procure uma maneira de usar a especificidade antes mesmo de considerar !important;

        - Use apenas !important CSS específico de página que substitui CSS externo (de bibliotecas externas, como Bootstrap ou normalize.css);

        - Nunca use !important quando estiver escrevendo um plugin / mashup;

        - Nunca use !important CSS em todo o site.

    Em vez de usar !important, considere:

        - Faça melhor uso da cascata CSS;

        - Use regras mais específicas. Ao indicar um ou mais elementos antes do elemento que você está selecionando, a regra se torna mais específica e obtém maior prioridade;

            Exemplo:
                 
                - div#test span { color: green; }

                    (0, 1, 0, 2)


                - div span { color: blue; }

                    (0, 0, 0, 2)

                - span { color: red; }

                    (0, 0, 0, 1)

        - Como um caso especial sem sentido para (2), duplique os seletores simples para aumentar a especificidade quando você não tiver mais nada a especificar. 

            Exemplo:
                        
                - #myId#myId span { color: yellow; }

                - .myClass.myClass span { color: orange; }

    Quando !important pode ser usado:

        - Substituindo estilos embutidos            

            - <div class="foo" style="color: red;">What color am I?</div>

            - .foo[style*="color: red"] { color: firebrick !important;}

        - Substituindo alta especificidade

            - #someElement p { color: blue; }

            - p.awesome { color: red !important;}

    Como substituir !important

        Adicione outra regra CSS com !importante dê ao seletor uma especificidade mais alta (adicionando uma tag, id ou classe ao seletor) ou adicione uma regra CSS com o mesmo seletor em um ponto posterior ao existente. Isso funciona porque em um empate de especificidade, a última regra definida vence ou podemos adicionar o mesmo seletor após o existente ou de preferência, reescrever a regra original para evitar o uso de !importantcompletamente.       

*/